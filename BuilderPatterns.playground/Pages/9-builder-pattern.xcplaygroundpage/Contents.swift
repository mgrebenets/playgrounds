//: [Main](1-main)

import UIKit

/*:
 ## Builder Pattern
 
 A classic design pattern described by GoF and adopted by our fellow Android developers.
 
 The idea is to create a special builder type, which is responsible for building the original object in question.
 
 ```
 public class Builder {
    // ..
 }
 ```
 
 Builder is a reference type (`class`), which is required to implement the [Fluent Interface](https://en.wikipedia.org/wiki/Fluent_interface) pattern (see below).

 The builder mirrors all the properties of the model, which is often quoted as the pattern disadvantage.
 
 ```
 private var name: String
 private var amount: Double
 private var picture: UIImage?
 ```
 
 Usually, for each property builder provides a setter function, that implements a [Fluent Interface](https://en.wikipedia.org/wiki/Fluent_interface) pattern, which basically means that the function returns `Self` and enables chaining calls.
 
 However, builder doesn't have to establish one-to-one matching between model properties and setters. Builder operates in _blocks_. It just so happens that by default one block constructs one property, but it doesn't have to be like that all the time.
 
 That's why the properties are declared as private.
 
 ```
 public func name(name: String) -> Builder {
     self.name = name
     return self
 }

 public func amount(amount: Double) -> Builder {
     self.amount = amount
     return self
 }

 public func picture(picture: UIImage?) -> Builder {
     self.picture = picture
     return self
 }
 
 // A hypothetical example of a block that builds amount and name from string
 public func someBuildingBlock(string: String) -> Builder {
    // TODO: parse name and amount from string input
    return self.name(name).amount(amount)
 }
 ```
 
 Chaining allows to write readable code, which looks similar to initializer calls, but unlike initializers it allows to set the properties in any order.

 ```
 // Chaining
 builder.name("XBOX").amount(100)
 ```

 The app is providing builder properties one by one and in the end asks the builder to build an instance of the model type.
 
 ```
 let goal = try builder.build()
 ```
 
 Note that we get proper model validation this way and are safe from creating incomplete models with meaningless defaults.
 
 When we need to construct new version of the model, we ask model to return current version of the builder and use the builder then.
 
 ```
 let builder = goal.builder
 builder.amount(400)
 let updatedGoal = try builder.build()
 ```
 
 An interesting suggestion came as a feedback after architecture meeting.
 Each building block can also handle validation by itself. This way validation is not delayed until the moment `build` is called.
 
 ```
 public func amount(amount: Double) throws -> Builder {
    guard amount > 0 else { throw Error.invalidAmount }
    self.amount = amount
    return self
 }
 ```

 For more details and implementation example see `GoalWithBuilder.swift`.

 ## Pros

 We get complete, valid and properly immutable model objects.
 
 We have all the error handling available, since the model is created only when all the input for it is ready.
 
 We get a universal design pattern provided by the model (often as part of framework), so there's no need to re-invent the bicycle for each individual developer or Scrum team every time they need to solve the original problem.

 Widely adopted design pattern, which has proven its best in Java, Android and apparently .NET world. What is a new and unexplored alternative for some of us in Swift world, for a _good_ Android developer is not even a question. They follow a pattern and save a lot of their time, which otherwise would be spent on discussions and arguments.
 
 When the same pattern is adopted across all Swift code base, we totally eliminate useless arguments like "but this is how we do it in CommBank / <your project name here>". Instead we take the best from internal open source and cross-polination approaches.

 ## Cons
 
 Extra code, since builder basically mirrors the original model.
 
 However, since the builder is part of the model, the two are created and refactored together, so this argument often degrades to totally subjective _keystrokes argument_, e.g. "I have more keys to press!".
 
 Potentially, with the right plugin, the builder code could be (re-) generated by IDE.
 
 A minor learning curve, which can be eliminated in the course of one architecture meeting.

 ## References
 
 - [.NET example](http://www.blackwasp.co.uk/Builder.aspx)
 - [Wikipedia](https://en.wikipedia.org/wiki/Builder_pattern)

 */


// Get the model builder
let goalBuilder = GoalWithBuilder.Builder()

// View controller 1 has the name
goalBuilder.name("XBOX")

// Try to create incomplete model
do {
    let goal = try goalBuilder.build()
} catch let error {
    // As expected the error is thrown
    print(error)
}

// View controller 2 gets goalBuilder from view controller 1
// It also has both amount and picture
// Note how the calls are chained due to fluent interface
goalBuilder.picture(UIImage()).amount(100)

// Now try to create complete model
do {
    let goal = try goalBuilder.build()
    print(goal)

    // Later on, we would want to update the model again
    // Get the builder for that
    let anotherBuilder = goal.builder
    anotherBuilder.amount(400)

    let modifiedGoal = try anotherBuilder.build()
    print(modifiedGoal)
} catch let error {
    print(error)
}
